<!DOCTYPE html>
<html lang="en">

<head>
	<title>Jacob_Le_HW1</title>
	<meta charset="utf-8">
	<style>
		body {
			margin: 0px;
			overflow: hidden;
		}
	</style>
</head>

<body>

	<div id="container"></div>

	<script src="https://threejs.org/build/three.min.js"></script>

	<script id="vertexShader" type="x-shader/x-vertex">
		
			//Three.js gives us these automatically when a perspective camera is bound to the renderer
			uniform mat4 modelMatrix;
			uniform mat4 viewMatrix;
			uniform mat4 projectionMatrix;

			//Three.js geometry creates these for us (and also texture coords, which we aren't using here)
			attribute vec3 position;
			attribute vec3 normal;

			//We are explicitly passing these in
			uniform vec3 light1_pos;
			uniform vec3 light2_pos;

			//uniform float time; 

			varying vec3 N, L1, L2, V;

			void main() {

				//get the vertex position in CAMERA coordinates
				vec4 position = viewMatrix * modelMatrix * vec4(position, 1.0);

				//use xyz vals to calculate vectors between vertex, light, and camera
				vec3 P = position.xyz;
		
				//get the normalized vertex normal in CAMERA coordinates
				N = vec3(normalize(viewMatrix * modelMatrix * vec4(normal.xyz, 0.0)  ).xyz) ;
		
				//the lights positions are defined in WORLD coordinates, we want to put them in CAMERA coordinates too
				vec4 L1_cam = viewMatrix * vec4(light1_pos, 1.0);
				vec4 L2_cam = viewMatrix * vec4(light2_pos, 1.0);
		
				//get the normalized vectors from each light position to the vertex positions
				L1 = vec3(normalize(L1_cam - position).xyz);
				L2 = vec3(normalize(L2_cam - position).xyz);
		
				//reverse direction of position vector to get view vector from vertex to camera
				V = normalize(-P);
		
		
				//of course, we always have to output our vertices in clip coords by multiplying through a projection matrix.
				gl_Position = projectionMatrix * position; 
			}
		</script>

	<script id="fragmentShader" type="x-shader/x-fragment">
			precision mediump float;
			
			varying vec3 V, N, L1, L2, L3;
			float spec_intensity = 32.0; //higher value indicates more rapid falloff

			uniform float time; 

			uniform vec3 ambient; //general ambient light in the scene applied to all objects

			uniform vec3 light1_diffuse;
			uniform vec3 light2_diffuse;

			uniform vec3 light1_specular;
			uniform vec3 light2_specular;


			void main() {

				vec4 outColor1 = vec4(0.0);
				vec4 outColor2 = vec4(0.0);
				
				//diffuse light depends on the angle between the light and the vertex normal
				float diff1 = max(0.0, dot(N, L1)); //just to make sure not negative
				vec3 color1 = diff1 * light1_diffuse;

				//For use with the textured object with phong lighting shader
				float diff2 = max(0.0, dot(N, L2));
				vec3 color2 = diff2 * light2_diffuse;

				//Third object will use lambert shading
				
				//specular highlights depend upon the position/orientation of the camera and the direction of the light reflecting off of this geometry
				vec3 R1 = normalize(reflect(-L1,N)); //get light vector reflected across the plane defined by the normal of this geometry
				float spec1 = pow( max(dot(R1, V), 0.0), spec_intensity); //raising the value to a particular intensity value shrinks the size of the specular highlight so that only a reflection vector (R1) that is very close to the view vector (V) will be applied to this fragment.
				
				color1 += spec1 * light1_specular;
				if (spec1 > 1.0) {
					outColor1 = vec4(light1_specular,1.0);
				} else {
					outColor1 = clamp(vec4(color1,1.0), 0.0,1.0);
				}
				
				//specular
				vec3 R2 = normalize(reflect(-L2,N));
				
				float spec2 = pow( max(dot(R2, V), 0.0), spec_intensity);
				color2 += spec2 * light2_specular;
				if (spec2 > 1.0) {
					outColor2 = vec4(light2_specular,1.0);
				} else {
					outColor2 = clamp(vec4(color2,1.0), 0.0,1.0);
				}
				
				gl_FragColor = clamp(vec4(ambient, 1.0) + outColor1 + outColor2, 0.0, 1.0); //add the two lights together, make sure final value is between 0.0 and 1.0
				}
        </script>

	<script>
		var container;

		var camera, scene, renderer;

		var vs = document.getElementById('vertexShader').textContent;
		var fs = document.getElementById('fragmentShader').textContent;

		var light1_pos, light2_pos;
		var light1_diffuse, light2_diffuse;
		var light1_specular, light2_specular;
		var point_light;

		var unique_mesh;

		init();
		animate();

		function init() {

			container = document.getElementById('container');

			camera = new THREE.PerspectiveCamera(50.0, window.innerWidth / window.innerHeight, 0.1, 10);
			camera.position.z = 5;

			scene = new THREE.Scene();

			var material1, material2, material3;

			// lights

			var ambient = new THREE.Vector3(0.1, 0.1, 0.1);

			light1_pos = new THREE.Vector3(0.0, 10.0, 0.0); //from above
			light1_diffuse = new THREE.Vector3(1.0, 0.0, 0.0);
			light1_specular = new THREE.Vector3(1.0, 1.0, 1.0);

			light2_pos = new THREE.Vector3(-10.0, 0.0, 0.0); //from the left
			light2_diffuse = new THREE.Vector3(0.0, 0.0, 1.0);
			light2_specular = new THREE.Vector3(1.0, 1.0, 1.0);

			point_light = new THREE.PointLight(0xdcf9d6, 1, 50, 2);
			point_light.position.set(10, 10, 10);
			scene.add(point_light);

			// geometry

			var geometry1 = new THREE.BoxGeometry(1, 1, 1);
			var geometry2 = new THREE.BoxGeometry(2, 2, 0.1);

			// Load custom geometry from blender
			function handle_load(geometry, materials){
				var useGeometry = geometry;

				var useMaterial = new THREE.MeshLambertMaterial({
					color: 0x2bc64f,
					emissive: 0x4ff275,
				});

				unique_mesh = new THREE.Mesh( useGeometry, useMaterial );

				unique_mesh.name = "unique_mesh";

				//positioning and scaling blender obj so that it's in the center of the screen
				unique_mesh.position.set( 3, -1.5, 0 );
				var s = 0.4;
				unique_mesh.scale.set( s, s, s );
				unique_mesh.rotation.y = -Math.PI / 4;

				scene.add( unique_mesh );
			}
			var loader = new THREE.JSONLoader();
			loader.load("mesh.json", handle_load);

			// material

			var uniforms = {
				ambient: { type: "v3", value: ambient },
				light1_pos: { type: "v3", value: light1_pos },
				light1_diffuse: { type: "v3", value: light1_diffuse },
				light1_specular: { type: "v3", value: light1_specular },
				light2_pos: { type: "v3", value: light2_pos },
				light2_diffuse: { type: "v3", value: light2_diffuse },
				light2_specular: { type: "v3", value: light2_specular },
				time: { type: "f", value: 1.0 }
			};

			var material1 = new THREE.RawShaderMaterial({
				uniforms: uniforms,
				vertexShader: vs,
				fragmentShader: fs,
			});

			var material2 = new THREE.RawShaderMaterial({
				uniforms: uniforms,
				vertexShader: vs,
				fragmentShader: fs,
			});

			var mesh1 = new THREE.Mesh(geometry1, material1);
			mesh1.translateX(-2.0);
			scene.add(mesh1);


			var mesh2 = new THREE.Mesh(geometry2, material2);
			mesh2.translateX(0.0);
			scene.add(mesh2);

			renderer = new THREE.WebGLRenderer();
			renderer.setClearColor(0x999999);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);


			window.addEventListener('resize', onWindowResize, false);

		}

		function onWindowResize(event) {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}



		function animate() {
			requestAnimationFrame(animate);
			render();
		}

		function render() {

			var time = performance.now();

			var object1 = scene.children[0];
			object1.rotation.x = time * 0.0009;
			object1.rotation.y = time * 0.0005;

			var object2 = scene.children[1];
			object2.rotation.x = time * 0.0005;
			object2.rotation.y = time * 0.0009;
			object2.material.uniforms.time.value = time * 0.002;

			var object3 = scene.children[2];
			object3.rotation.z = time * 0.0007;
			object3.rotation.y = time * 0.0003;
			object3.material.uniforms.time.value = time * 0.003;

			var unique_obj = scene.getObjectByName("unique_mesh");
			unique_obj.rotation.z = time * 0.0007;
			unique_obj.rotation.y = time * 0.0003;

			//Change lights
			light1_pos.x = 0.1 * Math.cos(time);
			light2_pos.y = 0.2 * Math.sin(time);
			point_light.position.set(0.1 * Math.sin(time), 0.3 * Math.sin(time), 0.2 * Math.cos(time));

			renderer.render(scene, camera);
		}
	</script>
</body>

</html>